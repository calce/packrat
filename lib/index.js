// Generated by CoffeeScript 1.6.3
var Builder, Packrat, coffee, fs, merge, path, read, sqwish, stylus, uglify, util, write, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Builder = require('component-builder');

path = require('path');

fs = require('fs');

read = fs.readFileSync;

write = fs.writeFile;

stylus = require('./stylus');

coffee = require('./coffee');

util = require('util');

sqwish = require('sqwish');

uglify = require('uglify-js');

_ = require('lodash');

Packrat = (function() {
  function Packrat(options, server, app) {
    var connectr, faye, self;
    this.server = server;
    this.app = app;
    this.channel = '/packrat';
    this.watching = false;
    console.log('packrat init');
    _.bindAll(this, ['publishChanges', 'pageReload', 'change', 'build', '_rebuild']);
    options = options || {};
    options.coffee = options.coffee || true;
    options.stylus = options.stylus || true;
    options.path = options.path || process.cwd();
    options.publicPath = options.publicPath || options.path + "/public";
    options.cssExts = options.cssExts || ['.css', '.styl', '.less', '.sass'];
    options.jsExts = options.jsExts || ['.js', '.coffee'];
    options.cssFileName = options.cssFileName || 'styles.css';
    options.jsFileName = options.jsFileName || 'javascripts.js';
    this.options = options;
    self = this;
    if (this.app && "development" === this.app.get('env')) {
      faye = require('faye');
      self.pub = new faye.NodeAdapter({
        mount: '/faye',
        timeout: 45
      });
      if (this.server) {
        self.pub.attach(this.server);
      }
      self.pub.addExtension({
        incoming: function(message, callback) {
          var client;
          if (message.channel === '/meta/subscribe') {
            return callback(message);
          }
          if (message.subscription !== self.channel) {
            return callback(message);
          }
          client = self.pub.getClient();
          self.publishChanges();
          console.log(message);
          return callback(message);
        }
      });
      connectr = require('connectr')(this.app);
      this.app.stack[1].handle.label = 'express';
      this.app.packratPayload = read(__dirname + '/../faye-browser.js', "utf8") + read(__dirname + '/browser/packrat.js');
      connectr.after('express').use(function(req, res, next) {
        res.packrat = self;
        self._patch(res);
        return next();
      });
    }
    this.build(function(err) {
      if (err) {
        return console.log(err);
      }
    });
  }

  Packrat.prototype._render = function(view, options, fn) {
    var accept, app, req, res;
    res = this;
    req = res.req;
    app = res.app;
    accept = req.headers.accept || '';
    return res._render(view, options, function(err, str) {
      if (err) {
        console.log(err);
        return req.next(err);
      } else if (accept.indexOf("html") === -1 || req.xhr) {
        return res.send(str);
      } else {
        str = require('./utils').injectHtml(str, '<style id="packrat-css">' + res.packrat.css + '</style>', '<script id="packrat-scripts" type="text/javascript">' + app.packratPayload + res.packrat.js + '</script>');
        if (typeof fn === "function") {
          return fn(err, str);
        } else {
          return res.send(str);
        }
      }
    });
  };

  Packrat.prototype._patch = function(res) {
    res._render = res.render;
    return res.render = this._render;
  };

  Packrat.prototype.publishChanges = function() {
    var client;
    client = this.pub.getClient();
    client.publish(this.channel, {
      css: this.css,
      js: this.js
    });
    return console.log('assets packed, publishing...');
  };

  Packrat.prototype.pageReload = function() {
    var client;
    client = this.pub.getClient();
    client.publish(this.channel, {
      reload: true
    });
    return console.log('assets packed, need page reload');
  };

  Packrat.prototype.change = function(filePath) {
    var self;
    console.log('files changed: ' + filePath);
    self = this;
    return this._rebuild(filePath);
  };

  Packrat.prototype._rebuild = function(filePath) {
    var self;
    self = this;
    return this.build(function(err) {
      var _ref, _ref1;
      if (err) {
        return console.log(err);
      }
      if (_ref = path.extname(filePath), __indexOf.call(self.options.cssExts, _ref) >= 0) {
        self.publishChanges();
      }
      if (_ref1 = path.extname(filePath), __indexOf.call(self.options.jsExts, _ref1) >= 0) {
        return self.pageReload();
      }
    });
  };

  Packrat.prototype.build = function(done) {
    var script, self, style, _i, _j, _len, _len1, _ref, _ref1;
    self = this;
    this.builder = new Builder(this.options.path);
    if (this.options.coffee) {
      this.builder.hook("before scripts", coffee(this));
    }
    if (this.options.stylus) {
      this.builder.hook("before styles", stylus(this));
    }
    if (Array.isArray(this.options.scriptHooks)) {
      _ref = this.options.scriptHooks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        script = _ref[_i];
        this.builder.hook("before scripts", script(this));
      }
    }
    if (Array.isArray(this.options.styleHooks)) {
      _ref1 = this.options.styleHooks;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        style = _ref1[_j];
        this.builder.hook("before styles", style(this));
      }
    }
    this.builder.copyAssetsTo(this.options.publicPath);
    return this.builder.build(function(err, res) {
      var chokidar, watcher;
      if (err) {
        return console.log(err);
      }
      self.css = res.css;
      self.js = res.require + res.js.replace(/\.coffee/g, ".js");
      if (err) {
        console.log(err);
      }
      console.log('assets packed.');
      if (self.app && "development" === self.app.get('env')) {
        if (!self.watching) {
          chokidar = require('chokidar');
          watcher = chokidar.watch(self.options.path + '/components', {
            ignored: /^\./,
            ignoreInitial: true
          });
          self.watching = true;
          console.log("watching " + self.options.path + '/components');
          watcher.on('add', self.change);
          watcher.on('change', self.change);
          watcher.on('unlink', self.change);
          watcher.on('error', function(err) {
            return console.log(err);
          });
        }
      }
      write("" + self.options.publicPath + "/" + self.options.cssFileName, self.css, function(err) {
        if (err) {
          return console.log(err);
        }
      });
      write("" + self.options.publicPath + "/" + self.options.jsFileName, self.js, function(err) {
        if (err) {
          return console.log(err);
        }
      });
      if (done) {
        return done(err);
      }
    });
  };

  return Packrat;

})();

merge = function(a, b) {
  var key;
  if (a && b) {
    for (key in b) {
      a[key] = b[key];
    }
  }
  return a;
};

merge(Packrat.prototype, require('events').EventEmitter.prototype);

module.exports = Packrat;
